{"meta":{"title":"ZZZ-Bin's Blog","subtitle":"They throw their shadows before them who carry their lantern on their back","description":null,"author":"ZZZ-Bin","url":""},"pages":[],"posts":[{"title":"事件循环 event loop","slug":"事件循环-event-loop","date":"2018-09-08T09:12:51.000Z","updated":"2018-09-09T14:40:58.011Z","comments":true,"path":"2018/09/08/事件循环-event-loop/","link":"","permalink":"/2018/09/08/事件循环-event-loop/","excerpt":"","text":"只有一个 event loop ，但任务队列可有多个： 123456789101112131415161718192021new Promise((resolve, reject) =&gt; &#123; resolve( )&#125;).then(( ) =&gt; &#123; console.log(1) new Promise((resolve, reject) =&gt; &#123; resolve( ) &#125;).then(( ) =&gt; &#123; console.log(2) &#125;) setTimeout(( ) =&gt; &#123; console.log(3) &#125;, 0)&#125;)console.log(4)setTimeout(( ) =&gt; &#123; console.log(5) &#125;, 0)// 4// 1// 2// 5// 3 `` 首先将所有代码放入 macrotask queue 中执行： ↑ 将匿名函数放入 microtask queue 中排队等待。 ↑ 控制台输出 ‘4’。 ↑ 放入 macrotask queue 中排队等待执行。 microtask queue : 1microtask1：/* P1.then 中的回调函数 */ macrotask queue 任务执行结束，检查 microtask queue ，发现 task1，将 task1 推出执行： ↑ 控制台输出 ‘1’。 ↑ 将 P2.then 中的匿名函数放入 microtask queue 中。 microtask queue: 1maicrotask2: /* P2.then 中的回调函数 () =&gt; console.log(2)*/ ↑ 放入 macrotask queue 中排队等待执行。 macrotask queue： 12macrotask1: () =&gt; console.log(5)macortask2: () -&gt; console.log(3) microtask1 执行结束，检查 microtask queue 发现 microtask2，推出执行： ↑ 控制台输出 ‘2’。 ##### microtask2 执行结束，检查 microtask queue ，microtask queue 为空，转而执行 macrotask queue 中的任务：macrotask1 执行，控制台输出 ‘5’。 macrotask2 执行，控制台输出 ‘3’。 macrotask queue 执行结束，检查 microtask queue， mirotask queue为空，event loop 结束。","categories":[],"tags":[{"name":"事件循环","slug":"事件循环","permalink":"/tags/事件循环/"},{"name":"event loop","slug":"event-loop","permalink":"/tags/event-loop/"},{"name":"异步","slug":"异步","permalink":"/tags/异步/"}]},{"title":"CommonJs 和 AMD/CMD","slug":"CommonJs-和-AMD-CMD","date":"2018-03-30T03:10:17.000Z","updated":"2018-09-09T14:43:04.345Z","comments":true,"path":"2018/03/30/CommonJs-和-AMD-CMD/","link":"","permalink":"/2018/03/30/CommonJs-和-AMD-CMD/","excerpt":"","text":"为什么我们要使用模块？因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。在解决一个复杂问题时，自顶向下逐层把系统划分成若干部分，有多种属性，分别反映其内部特性。 要实现模块化，就必须有一个前提，那就是统一标准。CommonJS、CMD 和 AMD 便应运而生了。 CommonJSCommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了 JavaScript 只能构建于浏览器之上这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的 JavaScript 解释器和不同的主机环境中。 CommonJS 定义的模块分为：{模块引用(require)} {模块定义(exports)}{模块标识(module)}require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。 Node.JS 便是 CommonJS 标准的一种实现，将 JavaScript 语言用于服务器端编程。浏览器并不兼容 CommonJS 的根本原因，在缺少四个 Node.js 环境的变量：module、eports、require、global。只要能提供这四个变量，浏览器就能加载 CommonJS 模块。下面是一个简单的示例： 12345678910var module = &#123; exports: &#123;&#125;&#125;;(function(module, exports) &#123; exports.multiply = function (n) &#123; return n * 1000 &#125;;&#125;(module, module.exports))var f = module.exports.multiply;f(5) // 5000 上面代码向一个立即执行函数提供 module 和 exports 两个外部变量，模块就放在这个立即执行函数里面。模块的输出值放在 module.exports 之中，这样就实现了模块的加载。 AMDCommonJS 规范虽然解决了 JavaScript “模块化”问题，但由于一个重大局限，使得它并不适合用于浏览器环境。如果在浏览器中运行，会有一个很大的问题，那就是require 是同步的。require 的阻塞加载会导致浏览器“假死”。在浏览器中只能想办法采用异步加载，AMD 便出现了。 它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 12345require(['math'], function (math) &#123; math.add(2, 3);&#125;); 它比 CommonJS 多了一个参数 callback ，既加载成功之后的回调函数。 目前，主要有两个 JavaScript 库实现了AMD规范：require.js 和 curl.js。 CMDCMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 AMD 与 CMD 的区别1.对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible。 2.CMD 推崇依赖就近，AMD 推崇依赖前置。 123456789101112131415161718// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() // 此处略去 100 行 var b = require('./b') // 依赖可以就近书写 b.doSomething() // ... &#125;) // AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() ...&#125;) 3.AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。 引用","categories":[],"tags":[{"name":"CommonJs","slug":"CommonJs","permalink":"/tags/CommonJs/"},{"name":"AMD","slug":"AMD","permalink":"/tags/AMD/"},{"name":"CMD","slug":"CMD","permalink":"/tags/CMD/"}]},{"title":"JavaScript 对象的深拷贝与浅拷贝","slug":"JavaScript-对象的深拷贝与浅拷贝","date":"2018-03-28T10:01:13.000Z","updated":"2018-09-09T09:13:24.147Z","comments":true,"path":"2018/03/28/JavaScript-对象的深拷贝与浅拷贝/","link":"","permalink":"/2018/03/28/JavaScript-对象的深拷贝与浅拷贝/","excerpt":"","text":"Object 的存储形式JavaScript 中Object以引用类型的形式保存在堆内存中，不许与直接访问与修改，在操作时也只是操作对象的引用。 将一个对象赋值给另一个对象。 1234var a = [1, 2, 3];var b = a;b.push(4);console.log(a); // [1, 2, 3, 4] 这就是由于对象类型直接赋值，只是将引用指向同一个地址，导致修改了obj1会导致obj2也被修改。 Object.assign( )ES6为我们提供了一种十分好用的方法，Object.assign(target, …source)方法 assign( ) 方法接受多个参数，第一个参数 target 为拷贝目标，剩余参数 …source 是拷贝源。此方法可以将 …source 中的属性复制到 target 中，同名属性会进行覆盖，并且在复制过程中实现了’伪’深拷贝。 在 Redux 的 reducer 中我们也用到了 Object： ...object,newValue: value 的形式来确保 reducer 本身是个纯函数的条件。 … ：扩展操作符（spread operator）并不是 ES6 语法的一部分，甚至都不是 ES Next 语法的一部分，但是因为其语法简单，已经被广泛使用，因为 babel 的存在，也不会有兼容性问题，所以我们可以完全放心使用。 ​ ——《深入浅出 React 和 Redux》 深拷贝与浅拷贝深拷贝和浅拷贝只针对像 Object, Array 这样的复杂对象的。简单来说，浅拷贝只拷贝一层对象的属性，而深拷贝则递归拷贝了所有层级。 下面是一个简单的浅拷贝实现： 123456789101112var obj = &#123; a:1, arr: [2,3] &#125;;var copyObj = Copy(obj);function Copy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125; 因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅拷贝会导致 obj.arr 和 copyObj.arr 指向同一块内存地址，所以导致的结果就是： 12copyObj.arr[1] = 5;console.log(obj.arr[1]); // 5 而深拷贝则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 copyObj 的 arr 属性指向同一个对象的问题。 12345678910111213function inCopy(obj1,obj2) &#123; var obj1 = obj1 || &#123;&#125;; //容错处理 for (var k in obj2) &#123; if(obj2.hasOwnProperty(k))&#123; //只拷贝实例属性，不进行原型的拷贝 if(typeof obj2[k] == 'object') &#123; //引用类型的数据单独处理 obj1[k] = Array.isArray(obj2[k])?[]:&#123;&#125;; inCopy(obj1[k],obj2[k]); //递归处理引用类型数据 &#125;else&#123; obj1[k] = obj2[k]; //值类型的数据直接进行拷贝 &#125; &#125; &#125;&#125; 需要注意的是，如果对象比较大，层级也比较多，深复制会带来性能上的问题。在遇到需要采用深复制的场景时，可以考虑有没有其他替代的方案。在实际的应用场景中，也是浅复制更为常用。 引用：javascript中的深拷贝和浅拷贝？","categories":[],"tags":[{"name":"深拷贝","slug":"深拷贝","permalink":"/tags/深拷贝/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"/tags/浅拷贝/"}]},{"title":"JavaScript中字面量、String()与new String()的差异","slug":"JavaScript-中字面量、String-与-new-String-的差异","date":"2018-03-27T13:13:59.000Z","updated":"2018-09-09T09:13:14.596Z","comments":true,"path":"2018/03/27/JavaScript-中字面量、String-与-new-String-的差异/","link":"","permalink":"/2018/03/27/JavaScript-中字面量、String-与-new-String-的差异/","excerpt":"","text":"我们知道在 JavaScript 中数据存储类型分为两种，即值类型和引用类型。 12345678var str = 'string';console.log(typeof(str1)); //Stringvar str2 = String('string'); console.log(typeof(str2)); //Stringvar str3 = new String('string');console.log(typeof(str2)); //Object ​ ​ 从上述代码中我们可以看出两种形式定义的字符串类型上的不同，字面量和 String() 定义的字符串类型为 String ，为值类型，存储在内存的栈中。而通过类定义的字符串类型为 Object ，为引用类型，存储在内存的堆中。 ​ 单独 String(&#39;segmentfault&#39;) 其实并不是面向对象形式的写法，你只能把它看做是一个 String 函数，其返回的就是 &#39;segmentfault&#39; 本身，所以和第一种结果一致。而通过类的实例化new String()定义的字符串，其类型自然是Object 那么问题来了，我们平时为何依然能对前两种方法创建的字符串调用各种方法或查看属性呢？ES规范是这样规定的：（以下内容转述自知乎问答的回答中） JS运行时首先会调用CheckObjectCoercible(baseValue)这样一个方法，在CheckObjectCoercible方法中会经行ToObject运算。而ES规范对ToObject中对String的运算描述原文如下： Create a new String object whose [[PrimitiveValue]] internal property is set to the value of the argument. 即创建了一个新对象，并将原文字符串的内容赋值给了这个对象的原始值。 字面量表示和String()并没有调用该函数。 那么通过这两种方法定义的字符串为什么可以调用String对象的诸多方法呢？ 引用来自于JS API文档的说明：通过’’或“”包裹的字符串或不作为构造函数调用String函数创建的字符串都是基本类型的字符串而非对象也就是typeof返回的是string 而非 object。而当基本类型的字符串调用String对象的方法时，JS引擎会自动将其包装成一个String对象","categories":[],"tags":[{"name":"字面量","slug":"字面量","permalink":"/tags/字面量/"},{"name":"String()","slug":"String","permalink":"/tags/String/"},{"name":"new String()","slug":"new-String","permalink":"/tags/new-String/"}]},{"title":"D3数据可视化","slug":"D3数据可视化","date":"2018-02-05T01:16:29.000Z","updated":"2018-02-05T01:51:42.872Z","comments":true,"path":"2018/02/05/D3数据可视化/","link":"","permalink":"/2018/02/05/D3数据可视化/","excerpt":"","text":"D3.js是什么D3是指数据驱动文档（Data-Driven Documents），官方定义： 1D3.js是一个JavaScript库，它可以通过数据来操作文档。D3可以通过使用HTML、SVG和CSS把数据鲜活形象地展现出来。D3严格遵循Web标准，因而可以让你的程序轻松兼容现代主流浏览器并避免对特定框架的依赖。同时，它提供了强大的可视化组件，可以让使用者以数据驱动的方式去操作DOM。 D3.js开发数据可视化，性能方面和highcharts,echarts对比区别Highcharts和echarts是一类东西，但跟d3.js维度不同。假如前面两个能解决你的需求，那么就可以先不考虑d3。 Highcharts和echarts基本上就是画图表用的，d3.js更自由一些，你很容易去做出自己想要的效果，比如mind chart、heat chart、tile chart之类的东西 而性能方面，简单图表都没什么问题，数据量大、复杂运算、动画效果多的话，都快不了，区别就是svg性能更差，canvas能好不少罢了。 绘制矩形本文绘制一个横向的柱形图。只绘制矩形，不绘制文字和坐标轴。 在 SVG 中，矩形的元素标签是 rect。例如： 1234&lt;svg&gt;&lt;rect&gt;&lt;/rect&gt;&lt;rect&gt;&lt;/rect&gt;&lt;/svg&gt; 上面的 rect 里没有矩形的属性。矩形的属性，常用的有四个： x - 矩形左上角的 x 坐标 y - 矩形左上角的 y 坐标 width - 矩形的宽度 height - 矩形的高度 要注意，在 SVG 中，x 轴的正方向是水平向右，y 轴的正方向是垂直向下的。 现在给出一组数据，要对此进行可视化。数据如下： 1var dataset = [ 250 , 210 , 170 , 130 , 90 ]; //数据（表示矩形的宽度） 为简单起见，我们直接用数值的大小来表示矩形的像素宽度（后面会说到这不是一种好方法）。然后，添加以下代码。 123456789101112131415var rectHeight = 25; //每个矩形所占的像素高度(包括空白)svg.selectAll(&quot;rect&quot;) .data(dataset) .enter() .append(&quot;rect&quot;) .attr(&quot;x&quot;,20) .attr(&quot;y&quot;,function(d,i)&#123; return i * rectHeight; &#125;) .attr(&quot;width&quot;,function(d)&#123; return d; &#125;) .attr(&quot;height&quot;,rectHeight-2) .attr(&quot;fill&quot;,&quot;steelblue&quot;); 这段代码添加了与 dataset 数组的长度相同数量的矩形，所使用的语句是： 1234svg.selectAll(&quot;rect&quot;) //选择svg内所有的矩形 .data(dataset) //绑定数组 .enter() //指定选择集的enter部分 .append(&quot;rect&quot;) //添加足够数量的矩形元素 这段代码以后会常常出现在 D3 的代码中，请务必牢记。目前不深入讨论它的作用机制是怎样的，只需要读者牢记，当： 有数据，而没有足够图形元素的时候，使用此方法可以添加足够的元素。 添加了元素之后，就需要分别给各元素的属性赋值。在这里用到了 function(d, i)，前面已经讲过，d 代表与当前元素绑定的数据，i 代表索引号。给属性赋值的时候，是需要用到被绑定的数据，以及索引号的。 最后一行的： 1.attr(&quot;fill&quot;,&quot;steelblue&quot;); 是给矩形元素设置颜色。一般来说，最好写成外置 CSS 的形式，方便归类和修改。这里为了便于初学者理解，将样式直接写到元素里。","categories":[],"tags":[]},{"title":"组件与元素","slug":"组件与元素","date":"2018-01-30T10:57:12.000Z","updated":"2018-09-09T09:14:01.835Z","comments":true,"path":"2018/01/30/组件与元素/","link":"","permalink":"/2018/01/30/组件与元素/","excerpt":"","text":"元素 React :React element它是 React 中最小基本单位我们可以使用 JSX 语法轻松地创建一个 React 元素: 1const element = &lt;div className=&quot;element&quot;&gt;I&apos;m an element&lt;/div&gt; React 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的： 1234567891011&#123; _context: Object, _owner: null, key: null, props: &#123; className: &apos;element&apos;， children: &apos;I&apos;m element&apos; &#125;, ref: null, type: &quot;div&quot;&#125; React 组件React 中有三种构建组件的方式。React.createClass()、ES6 class和无状态函数。 React.createClass()React.createClass()是三种方式中最早，兼容性最好的方法。在0.14版本前官方指定的组件写法。 12345var Greeting = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;); ES6 classES6 class是目前官方推荐的使用方式，它使用了ES6标准语法来构建，但它的实现仍是调用React.createClass()来实现了，ES6 class的生命周期和自动绑定方式与React.createClass()略有不同。 12345class Greeting extemds React.Component&#123; render: function() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;; 无状态函数无状态函数是使用函数构建的无状态组件，无状态组件传入props和context两个参数，它没有state，除了render()，没有其它生命周期方法。 123function Greeting (props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; React.createClass()和ES6 class构建的组件的数据结构是类，无状态组件数据结构是函数，它们在 React 被视为是一样的。 元素与组件的区别组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数 属性:props 一般属性是不改变的,经常作为传入的数据. 例: 建立PropsTest组件,在网页上输出简单的 Hello, XXX, XXX为传入的属性name,当name为空时,输出Hello,World 输入为其他值时,比如:Curry,输出Hello,Curry 1234567891011121314151617181920212223242526272829&lt;script type=&quot;text/babel&quot;&gt; class PropsTest extends React.Component&#123; render: function () &#123; return ( &lt;div&gt; Hello, &#123;this.props.name? this.props.name: &quot;World&quot;&#125; &lt;/div&gt; ); &#125; &#125;; ReactDOM.render( &lt;PropsTest name=&quot;Curry&quot;/&gt;, document.body ); &lt;/script&gt; 状态:state 一般状态是不断变化的,空间内部可以控制state的变化 例: 建立StateTest组件,实现在输入框中输入数据XXX,输入Hello, XXX. XXX随着输入框的输入内容而改变. 在render方法中定义Hello, {this.state.name}, 定义input,并添加onChange方法textChange, 在方法里面代码实现name的值随输入的值改变 代码如下: 1234567891011121314151617181920212223242526&lt;script type=&quot;text/babel&quot;&gt; class StateTest extends React.Component &#123; getInitialState: function () &#123; return &#123; name: &apos;World&apos; &#125; &#125;, textChange: function (event) &#123; this.setState(&#123; name: event.target.value &#125;); &#125;, render: function () &#123; return ( &lt;div&gt; &lt;p&gt;Hello, &#123;this.state.name&#125;&lt;/p&gt; &lt;input type=&quot;text&quot; onChange= &#123;this.textChange&#125; /&gt; &lt;/div&gt; ); &#125; &#125;; ReactDOM.render( &lt;StateTest /&gt;, document.body ); &lt;/script&gt; 状态和属性的相似点: 是纯js对象 改变会触发render方法 ​ 不同点: 属性值可以由父类传入,状态值不能 属性值不在组件内部修改,而状态值就是在组件内部修改的 [参考文章：React中元素与组件的区别]","categories":[],"tags":[{"name":"组件","slug":"组件","permalink":"/tags/组件/"},{"name":"元素","slug":"元素","permalink":"/tags/元素/"},{"name":"属性","slug":"属性","permalink":"/tags/属性/"},{"name":"状态","slug":"状态","permalink":"/tags/状态/"},{"name":"React","slug":"React","permalink":"/tags/React/"}]},{"title":"XSS","slug":"XSS","date":"2018-01-21T13:18:30.000Z","updated":"2018-01-22T02:16:28.135Z","comments":true,"path":"2018/01/21/XSS/","link":"","permalink":"/2018/01/21/XSS/","excerpt":"","text":"什么是XSS？跨站脚本攻击(Cross Site Scripting)，为了不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。 网络安全是每个程序猿不得不考虑的，初学者往往忽略了其重要性（比如我），为了避免造成较大的经济损失和不必要的人力物力，网络安全就应当成为程序员首要考虑的问题。可有道是道高一尺，魔高一丈，唯有不断学习，才能更有效的维护代码，实现代码的价值。 XSS分为：存储型和反射型（持久化、非持久化）存储型XSS：存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种XSS比较危险，容易造成蠕虫，盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。 反射型XSS：非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。 作为小白，你可能听不懂这些弯弯绕，那么通俗来讲，持久型XSS攻击就是把攻击数据存进数据库，攻击行为就伴随着攻击数据一直存在。非持久型XSS攻击是一次性的，仅对当次的页面访问产生影响。非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，而反射的xss 因为url特征更加容易被防御。 知己知彼方能百战不殆知道如何攻击才能思考如何防御，通常浏览器会过滤功能，比如使用Chrome浏览器打开一个带输入框的网页时，在输入框内输入 1&lt;script&gt;alert(1)&lt;/script&gt; 你就会看到效果。（一般很难找到这样的网页，自己写一个吧……） 低耦合高内聚（严于律己，宽以待人） 用正则","categories":[],"tags":[{"name":"xss","slug":"xss","permalink":"/tags/xss/"}]},{"title":"Less、Sass与Stylus浅谈","slug":"Less、Sass与Stylus浅谈","date":"2018-01-21T06:32:57.000Z","updated":"2018-09-09T09:13:39.237Z","comments":true,"path":"2018/01/21/Less、Sass与Stylus浅谈/","link":"","permalink":"/2018/01/21/Less、Sass与Stylus浅谈/","excerpt":"","text":"什么是CSS预处理器？CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，并且解决了传统CSS编写时遇到的难以解决的问题，如： 语法不够强大，无法嵌套书写导致复写很多内容 没有变量，逻辑上相关的属性需要重复书写，导致难以维护 现阶段主流CSS预处理器 Less、Sass、Stylus 都提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性，但其之中也略有不同，下面将通过几个方面来浅谈各预处理器之前的差异及优缺点。 历史 SASS，2007年诞生，最早也是最成熟的CSS预处理器，拥有ruby社区的支持和compass这一最强大的css框架，目前受LESS影响，已经进化到了全面兼容CSS的SCSS。 LESS，2009年出现，受SASS的影响较大，但又使用CSS的语法，让大部分开发者和设计师更容易上手，在ruby社区之外支持者远超过SASS，其缺点是比起SASS来，可编程功能不够，不过优点是简单和兼容CSS，反过来也影响了SASS演变到了SCSS的时代，著名的Twitter Bootstrap就是采用LESS做底层语言的。 Stylus，2010年产生，来自Node.js社区，主要用来给Node项目进行CSS预处理支持，在此社区之内有一定支持者，在广泛的意义上人气还完全不如SASS和LESS。 基本语法方面Less 的基本语法属于「CSS 风格」，而 Sass、Stylus 相比之下激进一些，利用缩进、空格和换行来减少需要输入的字符。不过区别在于 Sass、Stylus 同时也兼容「CSS 风格」代码。多一种选择在更灵活的同时，在团队开发中也免不了增加更多约定来保持风格统一。而对个人而言，语法风格按自己口味选择即可。 Less &amp; SCSS： 123.box &#123; display: block;&#125; Sass： 12.box display: block Stylus： 12.box display: block 嵌套语法三者的嵌套语法都是一致的，甚至连引用父级选择器的标记 &amp; 也相同。区别只是 Sass 和 Stylus 可以用没有大括号的方式书写。 &amp; 引用上层选择器 &amp;对伪类的使用 — hover或 focus&amp;对连接的使用— &amp;_nav 以 Less 为例： 12345.a &#123; &amp;.b &#123; color: red; &#125;&#125; 生成的 CSS 为： 123.a.b &#123; color: red;&#125; 变量变量无疑为 CSS 增加了一种有效的复用方式，减少了原来在 CSS 中无法避免的重复「硬编码」。 Less： 12345@red: #c00;strong &#123; color: @red;&#125; Sass： 12345$red: #c00;strong &#123; color: $red;&#125; Stylus： 1234red = #c00strong color: red 变量作用域三种预处理器的变量作用域都是按嵌套的规则集划分，并且在当前规则集下找不到对应变量时会逐级向上查找，注意这个和原生 CSS 的逻辑是完全不同的。 如果我们在代码中重写某个已经定义的变量的值，Less 的处理逻辑和其他两者有非常关键的区别。在 Less 中，这个行为被称为「懒加载（Lazy Loading）」。所有 Less 变量的计算，都是以这个变量最后一次被定义的值为准。（所以还是老老实实的用闭包的思想限定其作用域吧 -_- |||） @arguments@arguments包含了所有传递进来的参数。如果你不想单独处理每一个参数的话就可以像这样写原来的办法传参 123.border_arg(@w:30px,@c:red,@xx:solid)&#123; border: @w @c @xx;&#125; 现在的利用arguments 123456789.border_arg(@w:30px,@c:red,@xx:solid)&#123; border: @arguments;&#125;.test_arguments&#123; .border_arg();&#125;.test_arguments_2&#123; .border_arg(40px);&#125; 避免编译有的时候我们需要输出一些不正确的CSS语法或者使用一些LESS不认识的专有语法要输出这样的值我们可以在字符串前加上一个 ~ 例如： 1234567width:~’calc(100% - 30px)’;.test_03&#123; width: calc(300px - 20px);&#125;.test_04&#123; width: ~&apos;calc(300px - 20px)&apos;; //想不让less算，让浏览器算 用在calc 或者滤镜&#125; 引入外部的文件(一些库或公共的).less文件引入@import &quot;base&quot;; 默认后缀名是.less所以不用写.css文件引入`@import(less) “a.css”;` //注意(less)有空格，貌似我没用出来有待研究 三种预处理器，个人更加倾向于 Stylus，其相较 其他两者 来说，变量更易保持 ‘清洁’，且更加灵活的支持 「CSS 风格」，可选择性的使用何种方式编写样式，更有效的提高代码的可读性、可维护性，也有利于团队合作。","categories":[],"tags":[{"name":"CSS预处理器","slug":"CSS预处理器","permalink":"/tags/CSS预处理器/"},{"name":"Less","slug":"Less","permalink":"/tags/Less/"},{"name":"Sass","slug":"Sass","permalink":"/tags/Sass/"},{"name":"Stylus","slug":"Stylus","permalink":"/tags/Stylus/"}]},{"title":"js预处理初步分析与示例","slug":"js预处理初步分析与示例","date":"2018-01-14T12:32:56.000Z","updated":"2018-01-14T14:05:03.330Z","comments":true,"path":"2018/01/14/js预处理初步分析与示例/","link":"","permalink":"/2018/01/14/js预处理初步分析与示例/","excerpt":"","text":"JavaScript是一种描述型的脚本语言，它不同于java或C#等编译性语言,它不需要进行编译成中间语言,而是由浏览器进行动态地解析与执行。 代码并非由解析器直接逐行执行，所以理解javaScript语言的运行机制，掌握javascript的执行顺序，有利于我们学好JavaScript。 预处理（预编译）阶段：创建一个词法环境（LexicalEnvironment，在后面简写为LE），扫描代码中的用声明的方式声明的函数，和var定义的变量，并将它们加到预处理阶段的LE中去。 比如下面这段代码： 1234567var a = 10;(var定义的变量）function b( )&#123;console.log(&apos;这是一个声明方式声明的函数&apos;)&#125; 解析器在对代码进行预处理时，在全局LE中添加了如下内容： 123456789LE&#123;a = undefinded;function b( )&#123; console.log(&apos;这是一个声明方式声明的函数&apos;) &#125; 注意：在预处理阶段，以赋值方式创建的函数不会被添加到LE中去，而是将变量添加到LE，且值为undefinded。待代码执行上下文时才对该变量赋值（匿名函数） 比如： 123console.log(a);var a = function( )&#123; &#125; 其结果为 undefinded； 说明：全局预处理阶段在代码执行阶段前完成，并将代码中\b声明的变量 和 声明方式创建的函数加入全局的LE中（或等价于window） ，其中的变量即为全局变量。同时也解释了声明函数可在任意位置调用，而以表达式创建的函数（如构造函数的原型方法）必须在调用前声明。 我们还可以通过在浏览器的控制台中输入window. + “变量名”的方式确认该变量。 1234567var a;function b( )&#123;console.log(‘这是一个声明方式声明的函数’）&#125; 下面我们来做一个练习： 12345678910111213141516171819console.log(a);console.log(b);console.log(c);console.log(d);var a = 10;b = 15;function c( )&#123;&#125;;var d = function( )&#123;&#125;; 在预处理阶段做了这些事： 1234567891011LE&#123;a = undefinded;b没有被添加到LE中，所以这行会报错 b is not definded指向函数d不是声明方式创建的函数，所以d = undefinded&#125; 结果为： 123456789undefinded报错function c( )&#123;&#125;undefinded","categories":[],"tags":[]},{"title":"调整心态，做更好的自己","slug":"调整心态，做更好的自己","date":"2018-01-13T07:01:44.000Z","updated":"2018-01-14T13:10:00.108Z","comments":true,"path":"2018/01/13/调整心态，做更好的自己/","link":"","permalink":"/2018/01/13/调整心态，做更好的自己/","excerpt":"","text":"俗话说：心态决定一切。人难免会有负面情绪，及时调整心态确实能够帮助事情更好地发展，但小编认为更重要的是从自身做起，建立良好的心态，减少负面情绪的次数，更能帮助自我成长。下面介绍10个改变心态的途径。 1、确定奋斗目标有了明确而积极的目标，不良心态就慢慢抵消了。人之所以为人，区别其他动物的根本之处，就是人是有目标的。人丧失了生活目标，就和动物没有区别了。然而，现实中，很多人是没有明确的生活目标的。有一个有趣的现象，只有专业人员才知道，那就是：出租车什么时候最容易出事？答案是：在没有乘客的时候。原因很简单，没乘客时他的方向是盲目的，到十字路口左转右转，犹豫不决，当然容易出事。这是丧失目标的危害。这也是为什么有些人渴望退休享清闲，却发觉退下来后垮得更快的原因。 清晰的目标，必然产生坚定的信念，也必然产生坚定的力量，整个人生是这样，具体工作也是如此。 有人说：我都七老八十了，快要入土的人还要什么目标？你财富目标、事业目标没有了，还有人格目标、家庭目标和健康目标。即使其他目标都没有了，争取多活一天多看一天世界也就是目标。美国一心理学家曾组织100名80岁以上的老人定长寿计划，有57位的目标是活到100岁以上，结果后来活到100岁的有18位，全是原来计划中的老人。说明一个道理，定了目标的不一定都实现，而没定目标的肯定不能实现。 一个想当元帅的士兵99.99%不能当元帅，但是，一个不想当元帅的士兵100%当不了元帅。目标不同所激发出的能量相距很远。有目标才能产生远见 2、尝试挑战自我你越是害怕的事情，你越尝试着去做，定会改变自己。比如你有恐高症，你就有意爬高；你羞于讲话，你偏逼自己在会上发言，逼自己坐到显眼处；你胆小，你逼自己去蹦极；你口齿不灵，偏要与人去辩论。 3、运用暗示激励 心理学家说，有效的积极的心理暗示能提高自我价值的认识，建立充分的自信。包括：①自我言辞暗示，如：誓师大会、宣誓、座右铭等等暗示。有些算命先生就是运用了暗示的力量，使自己好像真算准了。毛泽东是无神论者，自幼就不信神，但为什么他在关键时刻又要找大师算卦呢？这就是希望用暗示激励扭转局面。②角色假定暗示，如想象自己就是某成功者，假定自己是承担某种特殊使命的人。③梦想板暗示。梦想板是目标量化的具体形式，就是将目标形象化。就是将你向望的理想，在脑海里形成一个具体明确的画面，也可以剪贴一张真实的画贴在墙上，经常不断的看，从而促使你的行动。如一款漂亮的轿车，一幢豪华的房子，一顶博士帽，一位意中人等。当你一看到梦想板的时候，你还可以吼一声：我一定要得到他！捏捏拳头。这不是疯子，是用潜意识力量，促使梦想实现。潜意识的力量是十分惊人的，早晚灌输，定能激发出巨大的潜能。运用梦想板有两个方法：一是不断想象，更新自我理想的图片；二是要不断自我暗示、自我确认、自我提醒。特别是在遇到困难、挫折以及满足现状时候。 4、待人宽容忍耐海纳百川，有容乃大。包容是一种智慧和美德，也是多少成功者的法宝，林肯说：把敌人变成朋友，既消灭了一个敌人，又多了一个朋友。容忍也是长寿的法宝。忍耐既是待人之法，又是处事之法。忍是一种眼光和度量，也是一种修养和策略，更是一种智慧。在小事上的忍耐，则是为了大事上的成功。小事不能忍的人难成大事。哲学家说：胸怀有多大，事业就有多大。 5、做事持之以恒1948年牛津大学请首相邱吉尔演讲，他说：我的成功秘诀有三个：第一是决不放弃；第二是决不、决不放弃；第三是决不、决不、决不放弃。我的演讲结束。一个成功人士有很多同路人：走100里路，前十里熙熙攘攘，摩肩接踵；50里时就稀稀朗郎,人声寥落；到后90里竟成孤家寡人了。故哲学家说：世界上没有失败者，只有放弃者和战死者。 6、品味享受生活做一件事情，你可以高高兴兴的做，也可以痛苦不堪的做，假若我们没法选择不做，就一定要选择高兴的去做。只要你选择快乐，以品味、享受的态度对待事务，任何痛苦都能忍受。比如你坐汽车，觉得很无聊，你若以享受的心态去坐，就会觉得轻松多了；饭菜难吃，你放到嘴里细细的品味，假设那是人间美味，就会觉得别有滋味。生孩子应该是最痛苦的事，但母亲们都能忍受是因为她们在期盼和享受快乐与幸福的到来。要这样想：生活的本来面目就是十有八九是不顺的，我们要“常想一二，不思八九”。 7、真诚奉献爱心爱心是积极心态的最佳表现。 爱默生说：人类最美好的补偿之一，就是人们真诚的帮助别人之后，同时也帮助了自己。一人为大家，大家为一人，这是人际关系的黄金定律。一个不知道关爱别人的人，也自然得不到别人的关爱。他就享受不了人间的快乐，终日像生活在地狱中。奉献爱心，也还要能愉快接受别人的爱心，一个老害怕麻烦别人的人，也常是心态消极的不会奉献爱心者。 8、营造人际网络任何人的成功，是靠别人，离开别人的帮助，就算你多牛也不行。谁的人际关系网络大，谁的活路就越多，谁的快乐就越多，谁的成就就越大，据研究表明，人的快乐85%是由人际关系决定的。在计划经济时代，一个职工只需要一个能力，就是业务能力，会干活就行，一辈子象螺丝钉一样拧在机器上，一门技术管几十年。可现在知识爆炸更替频繁的时代，除了业务能力（最基本的能力）外，还必须有另外两种能力：交际能力和学习能力。 ⑴交际能力（首要能力、现代能力、需要正本清源的能力，也是可以让其它能力倍增的能力。这也是计划经济和市场经济时代人的根本区别。 ⑵学习能力（可持续发展能力，现在必须终身学习，永续学习） 怎样建立好自己终生的人际关系网络，我这里重点介绍建立人际关系的六个秘诀： ①要微笑。笑，表示喜欢、接纳、亲和，它是融化冰冷漠然的和煦的春风，它是抵触封闭的万能钥匙，它是成功的契机。世界就像一面镜子，你对他微笑，他必以笑颜回报。相逢一笑泯恩仇。 ②要欣赏赞美别人。林肯说：人人爱听恭维的话。恭维别人，不是虚伪。恭维别人，就是肯定对方的价值。增强他的信心和勇气便于顺利交流，这是于人于己都有利的好习惯。他是改良人际关系的催化剂。学会了赞美别人，你看人的角度都发生了变化，再不会把别人看成豆腐渣了。事实上，人人都是有你值得学习和肯定的地方的。 ③常怀感恩之心。要善于感谢别人，不要为失去而烦恼，要为那些哪怕是微小的所得而报以感谢。常怀感激谢恩之心，必能严于律己，宽于待人。 ④要首先顾及别人利益。无论对方在意、计较与否，都要周到的考虑到对方的利益和需要。双赢才能长胜。 ⑤热情、幽默待人。任何人都愿意同热情洋溢、精力充沛、幽默风趣的人在一起。拿破伦-希尔说：如果你有热忱，几乎就所向无敌了。一句幽默的话语常能融化坚冰，化解矛盾。 ⑥讲诚、讲爱、少讲理。待人以诚才能人待以诚，包括诚实和守信。与人交往，常要有换位意识，多谅解别人，不要动不动就跟别人讲理。有时候，理讲赢了，事却输了，距离远了。在家里更是提倡讲爱、不讲理。越有道理越不能讲。 9、避闪环境杀手心理学家认为：人生下来的心态都是积极而健康的。就是《三字经》所说：人之初，性本善。导致心态变化的原因除教育以外，最重要一个因素就是环境影响。环境对人的影响和暗示不但深刻而巨大，而且无时无刻，防不胜防。所谓：近墨者黑，近朱者赤；跟好人学好人，跟端公跳假神，道理其实很简单。消极的环境影响，人们叫他环境杀手，对付他的办法只有一个，就是躲开，避闪，惹不起，还躲不起？ 成功大师李践关于避闪环境杀手有三条座右铭：读励志书；交成功人；避消极者。 10、细节决定成败细节决定成败—这是汪中求先生编著的的一本书的题目，他在开篇就提醒人们:精细化管理时代已经到来,每个人一定要注意细节,先把小事做好。（原因：一是高科技精细时代到来；二是人才专业细化所致；三是人才量大了，对人才要求更高，风风火火大而化之的没得儿子癞子也是好的的时代已经过去）很多企业的失败不是在大事上，而是在一些小的细节上疏忽了。例：270亿英镑资产巴林银行因一个88888的帐号在移交给时未消，被28岁小伙子里森钻了空子以之致倒闭；上海二号地铁因设计时比德国人设计的一号地铁少几步台阶而每年损失几千万；四川开县因细节管理疏漏而导致井喷。千里之堤溃于蚁穴的事自古就有。很多个人的失败也是失败在细节上。请记住一句名言：天使在想象中，魔鬼在细节里。","categories":[],"tags":[]},{"title":"My Frist Blog","slug":"myFristBlog","date":"2018-01-12T18:09:55.000Z","updated":"2018-01-12T18:25:10.932Z","comments":true,"path":"2018/01/13/myFristBlog/","link":"","permalink":"/2018/01/13/myFristBlog/","excerpt":"","text":"It was an exciting moment ！","categories":[],"tags":[{"name":"oh my jesus!","slug":"oh-my-jesus","permalink":"/tags/oh-my-jesus/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-12T17:38:31.621Z","updated":"2018-01-12T17:38:31.621Z","comments":true,"path":"2018/01/13/hello-world/","link":"","permalink":"/2018/01/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}