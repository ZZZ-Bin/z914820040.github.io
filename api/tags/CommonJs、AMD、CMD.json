{"name":"CommonJs、AMD、CMD","slug":"CommonJs、AMD、CMD","count":1,"postlist":[{"title":"CommonJs 和 AMD/CMD","slug":"CommonJs-和-AMD-CMD","date":"2018-03-30T03:10:17.000Z","updated":"2018-03-30T04:04:36.274Z","comments":true,"path":"api/articles/CommonJs-和-AMD-CMD.json","excerpt":"","keywords":null,"cover":null,"content":"<h3 id=\"为什么我们要使用模块？\"><a href=\"#为什么我们要使用模块？\" class=\"headerlink\" title=\"为什么我们要使用模块？\"></a>为什么我们要使用模块？</h3><p>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。在解决一个复杂问题时，自顶向下逐层把系统划分成若干部分，有多种属性，分别反映其内部特性。</p>\n<p>要实现模块化，就必须有一个前提，那就是统一标准。CommonJS、CMD 和 AMD 便应运而生了。</p>\n<h3 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h3><p>CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了 JavaScript 只能构建于浏览器之上这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的 JavaScript 解释器和不同的主机环境中。</p>\n<p>CommonJS 定义的模块分为：{模块引用(require)} {模块定义(exports)}{模块标识(module)}<br>require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。</p>\n<p>Node.JS 便是 CommonJS 标准的一种实现，将 JavaScript 语言用于服务器端编程。浏览器并不兼容 CommonJS 的根本原因，在缺少四个 Node.js 环境的变量：module、eports、require、global。只要能提供这四个变量，浏览器就能加载 CommonJS 模块。下面是一个简单的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = &#123;</span><br><span class=\"line\">  exports: &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports</span>) </span>&#123;</span><br><span class=\"line\">  exports.multiply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123; <span class=\"keyword\">return</span> n * <span class=\"number\">1000</span> &#125;;</span><br><span class=\"line\">&#125;(<span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"built_in\">module</span>.exports.multiply;</span><br><span class=\"line\">f(<span class=\"number\">5</span>) <span class=\"comment\">// 5000</span></span><br></pre></td></tr></table></figure>\n<p>上面代码向一个立即执行函数提供 module 和 exports 两个外部变量，模块就放在这个立即执行函数里面。模块的输出值放在 module.exports 之中，这样就实现了模块的加载。</p>\n<h3 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h3><p>CommonJS 规范虽然解决了 JavaScript “模块化”问题，但由于一个重大局限，使得它并不适合用于浏览器环境。如果在浏览器中运行，会有一个很大的问题，那就是<strong>require 是同步的</strong>。require 的阻塞加载会导致浏览器“假死”。在浏览器中只能想办法采用异步加载，AMD 便出现了。</p>\n<p>它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'math'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">math</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　math.add(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>它比 CommonJS 多了一个参数 callback ，既加载成功之后的回调函数。</p>\n<p>目前，主要有两个 JavaScript 库实现了AMD规范：<a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"noopener\">require.js</a> 和 <a href=\"https://github.com/cujojs/curl\" target=\"_blank\" rel=\"noopener\">curl.js</a>。</p>\n","text":"为什么我们要使用模块？因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。在解决一个复杂问题时，自顶向下逐层把系统划分成若干部分，有多种属性，分别反映其内部特性。要实现模块化，就必须有一个前提，那就是统一标准。CommonJS、CMD 和 AMD 便应运","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CommonJs、AMD、CMD","slug":"CommonJs、AMD、CMD","count":1,"path":"api/tags/CommonJs、AMD、CMD.json"}]}]}