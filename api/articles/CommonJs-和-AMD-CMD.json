{"title":"CommonJs 和 AMD/CMD","slug":"CommonJs-和-AMD-CMD","date":"2018-03-30T03:10:17.000Z","updated":"2018-03-30T06:10:55.878Z","comments":true,"path":"api/articles/CommonJs-和-AMD-CMD.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h3 id=\"为什么我们要使用模块？\"><a href=\"#为什么我们要使用模块？\" class=\"headerlink\" title=\"为什么我们要使用模块？\"></a>为什么我们要使用模块？</h3><p>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。在解决一个复杂问题时，自顶向下逐层把系统划分成若干部分，有多种属性，分别反映其内部特性。</p>\n<p>要实现模块化，就必须有一个前提，那就是统一标准。CommonJS、CMD 和 AMD 便应运而生了。</p>\n<h3 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h3><p>CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了 JavaScript 只能构建于浏览器之上这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的 JavaScript 解释器和不同的主机环境中。</p>\n<p>CommonJS 定义的模块分为：{模块引用(require)} {模块定义(exports)}{模块标识(module)}<br>require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。</p>\n<p>Node.JS 便是 CommonJS 标准的一种实现，将 JavaScript 语言用于服务器端编程。浏览器并不兼容 CommonJS 的根本原因，在缺少四个 Node.js 环境的变量：module、eports、require、global。只要能提供这四个变量，浏览器就能加载 CommonJS 模块。下面是一个简单的示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = &#123;</span><br><span class=\"line\">  exports: &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, exports</span>) </span>&#123;</span><br><span class=\"line\">  exports.multiply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">n</span>) </span>&#123; <span class=\"keyword\">return</span> n * <span class=\"number\">1000</span> &#125;;</span><br><span class=\"line\">&#125;(<span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"built_in\">module</span>.exports.multiply;</span><br><span class=\"line\">f(<span class=\"number\">5</span>) <span class=\"comment\">// 5000</span></span><br></pre></td></tr></table></figure>\n<p>上面代码向一个立即执行函数提供 module 和 exports 两个外部变量，模块就放在这个立即执行函数里面。模块的输出值放在 module.exports 之中，这样就实现了模块的加载。</p>\n<h3 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h3><p>CommonJS 规范虽然解决了 JavaScript “模块化”问题，但由于一个重大局限，使得它并不适合用于浏览器环境。如果在浏览器中运行，会有一个很大的问题，那就是<strong>require 是同步的</strong>。require 的阻塞加载会导致浏览器“假死”。在浏览器中只能想办法采用异步加载，AMD 便出现了。</p>\n<p>它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">'math'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">math</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">　　　　math.add(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>它比 CommonJS 多了一个参数 callback ，既加载成功之后的回调函数。</p>\n<p>目前，主要有两个 JavaScript 库实现了AMD规范：<a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"noopener\">require.js</a> 和 <a href=\"https://github.com/cujojs/curl\" target=\"_blank\" rel=\"noopener\">curl.js</a>。</p>\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p>\n<h3 id=\"AMD-与-CMD-的区别\"><a href=\"#AMD-与-CMD-的区别\" class=\"headerlink\" title=\"AMD 与 CMD 的区别\"></a>AMD 与 CMD 的区别</h3><p>1.对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible。</p>\n<p>2.CMD 推崇依赖就近，AMD 推崇依赖前置。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// CMD</span></span><br><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">var</span> a = <span class=\"built_in\">require</span>(<span class=\"string\">'./a'</span>)   </span><br><span class=\"line\">     a.doSomething()   </span><br><span class=\"line\">     <span class=\"comment\">// 此处略去 100 行   </span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>) <span class=\"comment\">// 依赖可以就近书写   </span></span><br><span class=\"line\">     b.doSomething()   <span class=\"comment\">// </span></span><br><span class=\"line\">     ... </span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">     </span><br><span class=\"line\"><span class=\"comment\">// AMD 默认推荐的是</span></span><br><span class=\"line\">define([<span class=\"string\">'./a'</span>, <span class=\"string\">'./b'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 依赖必须一开始就写好    </span></span><br><span class=\"line\">    a.doSomething()    </span><br><span class=\"line\">    <span class=\"comment\">// 此处略去 100 行    </span></span><br><span class=\"line\">    b.doSomething()    </span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>3.AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。</p>\n","categories":[],"tags":[{"name":"CommonJs、AMD、CMD","slug":"CommonJs、AMD、CMD","count":1,"path":"api/tags/CommonJs、AMD、CMD.json"}]}