{"title":"JavaScript 对象的深拷贝与浅拷贝","slug":"JavaScript-对象的深拷贝与浅拷贝","date":"2018-03-28T10:01:13.000Z","updated":"2018-04-02T09:27:27.000Z","comments":true,"path":"api/articles/JavaScript-对象的深拷贝与浅拷贝.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<h3 id=\"Object-的存储形式\"><a href=\"#Object-的存储形式\" class=\"headerlink\" title=\"Object 的存储形式\"></a>Object 的存储形式</h3><p>JavaScript 中<code>Object</code>以引用类型的形式保存在堆内存中，不许与直接访问与修改，在操作时也只是操作对象的引用。</p>\n<p>将一个对象赋值给另一个对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = a;</span><br><span class=\"line\">b.push(<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n<p><strong>这就是由于对象类型直接赋值，只是将引用指向同一个地址，导致修改了obj1会导致obj2也被修改。</strong></p>\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign( )\"></a>Object.assign( )</h3><p>ES6为我们提供了一种十分好用的方法，Object.assign(target, …source)方法</p>\n<p>assign( ) 方法接受多个参数，第一个参数 target 为拷贝目标，剩余参数 …source 是拷贝源。此方法可以将 …source 中的属性复制到 target 中，同名属性会进行覆盖，并且在复制过程中实现了’伪’深拷贝。</p>\n<p>在 Redux 的 reducer 中我们也用到了 <code>Object： ...object,newValue: value</code> 的形式来确保 reducer 本身是个纯函数的条件。</p>\n<blockquote>\n<p>… ：扩展操作符（spread operator）并不是 ES6 语法的一部分，甚至都不是 ES Next 语法的一部分，但是因为其语法简单，已经被广泛使用，因为 babel 的存在，也不会有兼容性问题，所以我们可以完全放心使用。</p>\n<p>​                                    ——《深入浅出 React 和 Redux》</p>\n</blockquote>\n<h3 id=\"深拷贝与浅拷贝\"><a href=\"#深拷贝与浅拷贝\" class=\"headerlink\" title=\"深拷贝与浅拷贝\"></a>深拷贝与浅拷贝</h3><p>深拷贝和浅拷贝只针对像 Object, Array 这样的复杂对象的。简单来说，浅拷贝只拷贝一层对象的属性，而深拷贝则递归拷贝了所有层级。</p>\n<p>下面是一个简单的浅拷贝实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">a</span>:<span class=\"number\">1</span>, <span class=\"attr\">arr</span>: [<span class=\"number\">2</span>,<span class=\"number\">3</span>] &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> copyObj = Copy(obj);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Copy</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dst = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> prop <span class=\"keyword\">in</span> src) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (src.hasOwnProperty(prop)) &#123;</span><br><span class=\"line\">      dst[prop] = src[prop];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dst;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为浅复制只会将对象的各个属性进行依次复制，并不会进行递归复制，而 JavaScript 存储对象都是存地址的，所以浅拷贝会导致 <code>obj.arr</code> 和 <code>copyObj.arr</code> 指向同一块内存地址，所以导致的结果就是：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copyObj.arr[<span class=\"number\">1</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.arr[<span class=\"number\">1</span>]);   <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>而深拷贝则不同，它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法<strong>递归复制</strong>到新对象上。这就不会存在上面 obj 和 copyObj 的 arr 属性指向同一个对象的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inCopy</span>(<span class=\"params\">obj1,obj2</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> obj1 = obj1 || &#123;&#125;;  <span class=\"comment\">//容错处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> obj2) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(obj2.hasOwnProperty(k))&#123;   <span class=\"comment\">//只拷贝实例属性，不进行原型的拷贝</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> obj2[k] == <span class=\"string\">'object'</span>) &#123;   <span class=\"comment\">//引用类型的数据单独处理</span></span><br><span class=\"line\">                obj1[k] = <span class=\"built_in\">Array</span>.isArray(obj2[k])?[]:&#123;&#125;;</span><br><span class=\"line\">                inCopy(obj1[k],obj2[k]);  <span class=\"comment\">//递归处理引用类型数据</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                obj1[k] = obj2[k];   <span class=\"comment\">//值类型的数据直接进行拷贝</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是，如果对象比较大，层级也比较多，深复制会带来性能上的问题。在遇到需要采用深复制的场景时，可以考虑有没有其他替代的方案。在实际的应用场景中，也是浅复制更为常用。</p>\n<p>引用：<a href=\"https://www.zhihu.com/question/23031215\" target=\"_blank\" rel=\"noopener\">javascript中的深拷贝和浅拷贝？</a></p>\n","categories":[],"tags":[{"name":"深拷贝、浅拷贝","slug":"深拷贝、浅拷贝","count":1,"path":"api/tags/深拷贝、浅拷贝.json"}]}